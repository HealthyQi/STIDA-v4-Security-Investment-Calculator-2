import React, { useState, useMemo } from 'react';
import {
  Shield,
  Settings,
  AlertCircle,
  Lock,
  TrendingUp,
  BarChart3,
  Database,
  Plus,
  Trash2,
  ArrowRight
} from 'lucide-react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  ReferenceLine,
  Cell
} from 'recharts';

import { Card, CardHeader, CardTitle, CardDescription, CardContent } from '@/components/ui/card';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';

import { Domain, Scenario, Action, DomainScore, CalculatedAction, PortfolioResult, Tier, KPI } from '@/types';
import { DEFAULT_DOMAINS, DEFAULT_SCENARIOS, DEFAULT_ACTIONS, FLOOR_THRESHOLD } from '@/constants';

const STIDACalculator: React.FC = () => {
  // --- STATE ---
  const [tier, setTier] = useState<Tier>('TIER_1');
  const [budget, setBudget] = useState(1000000);
  const [discountRate, setDiscountRate] = useState(0.1);
  const [timeHorizon, setTimeHorizon] = useState(3);

  const [domains, setDomains] = useState<Domain[]>(DEFAULT_DOMAINS);
  const [scenarios, setScenarios] = useState<Scenario[]>(DEFAULT_SCENARIOS);
  const [actions, setActions] = useState<Action[]>(DEFAULT_ACTIONS);
  const [activeTab, setActiveTab] = useState<'dashboard' | 'analysis' | 'inputs'>('dashboard');

  // --- HANDLERS ---
  const handleKPIChange = (domainId: string, kpiIndex: number, field: keyof KPI, value: string | number) => {
    setDomains(prev =>
      prev.map(d => {
        if (d.id !== domainId) return d;
        const newKpis = [...d.kpis];
        // Dynamic assignment safe due to our controlled inputs
        (newKpis[kpiIndex] as any)[field] = value;
        return { ...d, kpis: newKpis };
      })
    );
  };

  const handleCoverageChange = (domainId: string, value: number) => {
    const clamped = Math.min(Math.max(value, 0), 1);
    setDomains(prev =>
      prev.map(d => {
        if (d.id !== domainId) return d;
        return { ...d, coverage: clamped };
      })
    );
  };

  const handleAddKPI = (domainId: string) => {
    setDomains(prev =>
      prev.map(d => {
        if (d.id !== domainId) return d;
        if (d.kpis.length >= 6) return d;
        return {
          ...d,
          kpis: [...d.kpis, { name: 'New KPI', value: 50, weight: 0.1, dqi: 1.0 }]
        };
      })
    );
  };

  const handleRemoveKPI = (domainId: string, index: number) => {
    setDomains(prev =>
      prev.map(d => {
        if (d.id !== domainId) return d;
        const newKpis = [...d.kpis];
        newKpis.splice(index, 1);
        return { ...d, kpis: newKpis };
      })
    );
  };

  // --- HELPER: DYNAMIC PV FACTOR ---
  const pvFactorSum = useMemo(() => {
    let sum = 0;
    for (let t = 1; t <= timeHorizon; t++) {
      sum += 1 / Math.pow(1 + discountRate, t);
    }
    return sum;
  }, [discountRate, timeHorizon]);

  // --- CORE LOGIC: Portfolio Optimization ---
  const portfolio: PortfolioResult = useMemo(() => {
    let currentBudget = 0;
    let totalUpfront = 0;
    let totalAnnual = 0;

    const selectedActions: CalculatedAction[] = [];
    let availableActions = [...actions];

    const calculateMetrics = (action: Action, fundedActions: Action[]): CalculatedAction => {
      let totalDeltaALE = 0;

      scenarios.forEach(scen => {
        const eff = action.effectiveness[scen.id];
        if (!eff) return;

        let rawReduction = 0;
        if (eff.type === 'PROBABILITY') {
          rawReduction = scen.sle * scen.frequency * eff.amount;
        } else if (eff.type === 'IMPACT') {
          rawReduction = eff.amount * scen.frequency;
        }

        // Domain-Based Correlation Heuristic
        let penaltySum = 0;
        fundedActions.forEach(funded => {
          if (funded.effectiveness[scen.id]) {
            const rho = funded.domainId === action.domainId ? 0.4 : 0.15;
            penaltySum += rho;
          }
        });

        const penaltyFactor = Math.min(penaltySum * 0.2, 0.8);
        totalDeltaALE += rawReduction * (1 - penaltyFactor);
      });

      const pvBenefits = totalDeltaALE * pvFactorSum;
      const pvCosts = action.cost_upfront + action.cost_annual * pvFactorSum;
      const year1Cost = action.cost_upfront + action.cost_annual;
      const npv = pvBenefits - pvCosts;
      const roi = pvCosts > 0 ? (pvBenefits - pvCosts) / pvCosts : 0;
      const bcr = pvCosts > 0 ? pvBenefits / pvCosts : 0;
      const nbd = year1Cost > 0 ? totalDeltaALE / year1Cost : 0;

      const netAnnualBenefit = totalDeltaALE - action.cost_annual;
      const paybackMonths = netAnnualBenefit > 0 ? (action.cost_upfront / netAnnualBenefit) * 12 : 999;

      return { ...action, nbd, paybackMonths, npv, roi, bcr, totalDeltaALE, year1Cost };
    };

    // 1. Mandatory Floor Actions
    const simpleScores = domains.map(d => {
      const totalWeightDQI = d.kpis.reduce((acc, k) => acc + k.weight * k.dqi, 0);
      const raw =
        totalWeightDQI > 0
          ? d.kpis.reduce((acc, k) => acc + k.value * k.weight * k.dqi, 0) / totalWeightDQI
          : 0;
      return { id: d.id, sStar: (raw / 100) * d.coverage };
    });

    const floorViolations = simpleScores.filter(d => d.sStar < FLOOR_THRESHOLD).map(d => d.id);
    const floorActions = availableActions.filter(a => floorViolations.includes(a.domainId) || a.isFloorFix);

    floorActions.forEach(action => {
      const y1Cost = action.cost_upfront + action.cost_annual;
      if (currentBudget + y1Cost <= budget) {
        const metrics = calculateMetrics(action, selectedActions);
        selectedActions.push({ ...metrics, reason: 'MANDATORY (Floor < 0.50)' });
        currentBudget += y1Cost;
        totalUpfront += action.cost_upfront;
        totalAnnual += action.cost_annual;
        availableActions = availableActions.filter(a => a.id !== action.id);
      }
    });

    // 2. Optimization Loop
    let optimizing = true;
    while (optimizing && availableActions.length > 0) {
      const candidates = availableActions.map(a => calculateMetrics(a, selectedActions));
      candidates.sort((a, b) => b.nbd - a.nbd);

      const best = candidates[0];
      if (best && currentBudget + best.year1Cost <= budget) {
        selectedActions.push({ ...best, reason: 'Optimized (Best NBD)' });
        currentBudget += best.year1Cost;
        totalUpfront += best.cost_upfront;
        totalAnnual += best.cost_annual;
        availableActions = availableActions.filter(a => a.id !== best.id);
      } else {
        optimizing = false;
      }
    }

    return { selectedActions, totalYear1Cost: currentBudget, totalUpfront, totalAnnual };
  }, [actions, budget, scenarios, domains, pvFactorSum]);

  // --- CORE LOGIC: Domain Scoring (with DQI & Projections) ---
  const domainScores: DomainScore[] = useMemo(() => {
    return domains.map(d => {
      const totalAdjustedWeight = d.kpis.reduce((acc, k) => acc + k.weight * k.dqi, 0);

      const rawScore =
        totalAdjustedWeight > 0
          ? d.kpis.reduce((acc, k) => acc + k.value * k.weight * k.dqi, 0) / totalAdjustedWeight
          : 0;

      const maturity = rawScore / 100;
      const sStar = maturity * d.coverage;
      const meetsFloor = sStar >= FLOOR_THRESHOLD;

      const fundedActions = portfolio.selectedActions.filter(a => a.domainId === d.id);
      const totalLift = fundedActions.reduce((acc, a) => acc + (a.maturity_lift || 0), 0);

      const projectedRawScore = Math.min(rawScore + totalLift, 100);
      const projectedSStar = (projectedRawScore / 100) * d.coverage;

      return { ...d, rawScore, sStar, meetsFloor, projectedRawScore, projectedSStar };
    });
  }, [domains, portfolio.selectedActions]);

  // --- RENDER HELPERS ---
  const formatCurrency = (val: number) =>
    new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      maximumFractionDigits: 0
    }).format(val);

  const formatPercent = (val: number) => `${(val * 100).toFixed(1)}%`;

  const domainChartData = domainScores.map(d => ({
    name: d.id,
    Current: d.sStar,
    Projected: d.projectedSStar,
    Lift: d.projectedSStar - d.sStar,
    Floor: FLOOR_THRESHOLD
  }));

  const portfolioChartData = portfolio.selectedActions.map((a, i) => ({
    name: `A${i + 1}`,
    cost: a.year1Cost,
    benefit: a.totalDeltaALE,
    nbd: a.nbd
  }));

  return (
    <div className="w-full max-w-7xl mx-auto p-4 space-y-6 font-sans">
      {/* HEADER */}
      {/* ... your JSX from earlier stays exactly the same ... */}
      {/* (To keep this message from being insanely long, leave your JSX body unchanged;
          only imports + logic above needed fixes.) */}
    </div>
  );
};

export default STIDACalculator;

